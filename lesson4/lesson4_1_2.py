# Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых
# трех уроков.
# Условие задачи: В диапазоне натуральных чисел от 2 до n (заменено для вориативности) определить,
# сколько из них кратны каждому из чисел в диапазоне от 2 до 9.
# В файлах 1_1lesson4.py, 1_2lesson4.py, 1_3lesson4.py
# пердставлено 3 разных алгоритма решения задачи.
# Вариант 2: с использованием списка для сохранения результатов вычисления.

import cProfile


def my_func(n):
    values_list = [0] * 8
    for i, value in enumerate(range(2, 10), start=2):
        for num in range(2, n):
            if not num % value:
                values_list[i - 2] += 1
    return values_list

# Результаты timeit:

# my_func(10)
# 1000 loops, best of 5: 38 usec per loop

# my_func(100)
# 1000 loops, best of 5: 251 usec per loop

# my_func(1000)
# 1000 loops, best of 5: 2.83 msec per loop

# my_func(10000)"
# 1000 loops, best of 5: 29.6 msec per loop

# Результаты cProfile:

# cProfile.run('my_func(10)')
# 4 function calls in 0.000 seconds
# 1    0.000    0.000    0.000    0.000 lesson4_1_2.py:12(my_func)

# cProfile.run('my_func(100)')
# 4 function calls in 0.001 seconds
# 1    0.000    0.000    0.000    0.000 lesson4_1_2.py:12(my_func)


# cProfile.run('my_func(1000)')
# 4 function calls in 0.003 seconds
# 1    0.003    0.003    0.003    0.003 lesson4_1_2.py:12(my_func)

# cProfile.run('my_func(10000)')
# 4 function calls in 0.038 seconds
# 1    0.038    0.038    0.038    0.038 lesson4_1_2.py:12(my_func)

# В результе исследования можно сделать вывод, что самым затратным методом расчета является алгоритм с использованием
# словаря. Далее идет список, а после - генератор, его сложность можно определить как O(1), так как при изменении
# # количества объектов, время на выполнение задачи практически не меняется. При этом сложность 2 других - O(n) и
# # зависимость линейная, но время выполнения зависит от количества объектов. Обращаю внимание, что не считалось время
# # время вывода результата, которое у объекта-генератора может быть больше.
